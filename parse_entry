#!/bin/bash

# Parse a bibliographical entry and tags it. Uses the data available in tags/

# The following function tries to isolate 'semantic entities' (i.e. blocks of
# text that have a meaning together) and to find them in the tags/* files.
#
# When that works, the bibliographical entry is tagged with the name of the
# tags/* file that matches.
#
#
# ====> THIS FUNCTION SHOULD BE *CLEAN*, i.e. NO F**** GUESSES HERE <====
#
# (it must work for *all* kinds of keywords at once)
tagfiles="-f $(find tags/ -type f -o -type l -not -name journal | xargs echo | sed 's/ / -f /g')" # except 'journal'
function auto_annotate_from_db() {
    #echo "$l" >&2
    l="$(echo "$*" | sed "s/ *,[,\. ]*/, /g")"

    l_save="$l"
    while read content; do
	content_reg="$(echo "$content" | perl -ne 'print quotemeta($_)')"
        l="$(echo ${l}, | perl -ape "s/([,\(;\):0-9] +)$content_reg *([\(\),\.0-9])/\1 ╠?=$content_reg╣, \2/g")"
    done < <(echo "$l" | perl -ape "s/╠[^╣]*╣//g" | grep -o -F $tagfiles)
    l="$(echo "$l" | perl -ape "s/,[,\. ]*/, /g")"

    if [ "$l" = "$l_save" ]; then
	echo "$l"
    else
	auto_annotate_from_db "$l"
    fi
}

function auto_annotate_from_db_greedy() {
    l="$*"
    for t in tags/*; do
	while read o; do
	    l="$(echo "$l" | replace " $o" ", ╠$(basename "$t")=$o╣, ")"
	done < <(echo "$l" | sed "s/╠[^╣]*╣, */, /g" | grep -o -w -F -f "$t")
    done
    echo "$l"
}

function get_tag () {
    while read a; do
	echo "$a" | grep -o -P "╠$1=[^╣]*╣" | perl -ape "s/^.*=(.*)╣$/\1/g"
    done
}

function replace () {
    while read a; do
	echo "${a/$1/$2}"
    done
}

# Specific function to guess the journal's name. We must try harder, for journal
# names contain lots of '.', and sometimes appear right after the '.' at the end
# of the title. Sometimes they also contain ','
function parse_journal_from_db() {
    i="$*"

    if echo "$i" | grep -P "╠journal=" > /dev/null; then
	echo "$i" && return 0
    fi

    while read j; do # nonempty journal
	jp="$(echo "$j" | perl -ne 'print quotemeta($_)')"
    	i="$(echo "$i" | perl -ape "s/([[:lower:]][^ ]*\.|[,0-9:;]) *( [Ii]n)* +${jp} *([,\.0-9;:])/\1, ╠journal=${jp}╣, \3/g")"
    done < <(echo "$i" | perl -ape "s/╠.*?╣//g" | grep -F -o -f tags/journal)

    echo "$i"
}

cardinal_regex="((first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|eleventh|twelfth|thirteenth|fourteenth|fifteenth|sixteenth|seventeenth|eighteenth|nineteenth|twentieth|twenty|thirty|forty|fifty|[0-9]+ *[[:lower:]]{2} )[ \-]*)*"

function parse_proceedings () {
    p="$(echo "$*" | perl -ape "s/╠.*?╣//g" | grep -i -E -o "(in[: ]+|[\.,\(\):] *)Proc(\.|eedings*) *((of|the) *)*($cardinal_regex)*(annual)* *" | head -n 1)"
    if [ -n "$p" ]; then
	echo "$*" | replace "$p" ", ╠proceedings╣, "
	return 0
    fi
    echo "$*"
    return 0
}

function guess_authors () {
    b="$(echo "$*" | sed "s/^.*\] *//"g | sed "s/[”“╠].*//g")"

    # Starts with Initials.
    # Meant to match the following pattern: I. K. Whatever, K.L. Whateverrr[.,] and O. Thing and J. van der Stuff[.,]
    if [ "${b:1:1}" = "." ]; then
	aut="$(echo $b | \grep -P -o "^(((([[:upper:]]\.[- ]*)+,*)+ *([a-z]{1,4} )*)[^ ]+( and|[[:punct:]]) *)*")"
	echo "$*" | replace "$aut" "╠authors=$aut╣, "
	return 0
    fi

    # Same in the other order, i.e. Whatever I. K., Whateverrrrr K. L., #
    aut="$(echo $b | \grep -P -o "^((\w{1,4} )*[^ ]+[[:punct:]]* +([[:upper:]][[:punct:]]+ *)+( and|[[:punct:]])* *)*(et al\.[ [[:punct:]]]*)*")"
    if [ -n "$aut" ]; then
	echo "$*" | replace "$aut" "╠authors=$aut╣, "
	return 0
    fi

    # Victor P. Whatever, Nicolas E. G. H. H. Thingy, and Whatever Whathehell,
    aut="$(echo "$b" | grep -P -o "^([[:upper:]][^ ,\.:;]+ ([[:upper:]]\. +)*[[:upper:]][^ ,\.:;]+([,\.:;]* and|[,\.:;]) +)+")"
    if [ -n "$aut" ]; then
	echo "$*" | replace "$aut" "╠authors=$aut╣, "
	return 0
    fi

    echo "$*"
}

function longest_line () {
    while read a; do
	if [ ${#l} -lt ${#a} ]; then
	    l="$a"
	fi
    done
    echo "$l"
}
function guess_title () {
    b="$(echo "$*" | sed "s/^.*authors=[^╣]*╣[,\. ]*//" | sed "s/╠.*//g" | grep -P -o "[“ ]*[[:upper:]][^,\.”]*([,\. ]+[[:lower:]][^,\.]*)*" | perl -ape "s/^( |[[:punct]]|“)*//g" | longest_line)"
    echo "$*" | replace "$b" ", ╠title=$b╣, "
}


cat |
    sed "s/$/, , , , ,/" |
    sed "s/[\`˚ˆˇ´´¨¨˝˜] *\([[:lower:]]\)/\1/g" | # Bad accents
    perl -ape "s| +// +|, |g" |
    perl -ape "s/ doi *[:\. ]*(10[^ ]+[^\.,:; ])/, ╠doi=\1╣, /ig" |
    perl -ape "s/(url[ [[:punct:]]]*)*[^ ]*[[:punct:]]doi[[:punct:]][^ ]*(10(([\.\/] *)+[^, ]+)+[^\.,:; ])/, ╠doi=\2╣, /ig" |
    perl -ape "s/http[:\/ ]*dx[\. ]*doi[\. ]*org *\/ *([^ ]*[^ ,\.:;])/, ╠doi=\1╣, /g" |
    perl -ape "s/ MR[: ]*([0-9]{6})/, ╠MR=\1╣, /g" |
    perl -ape "s/([ ,(])(ISBN(-13|-10)*|ISSN)[ :\-#]+(([0-9]+[ -]*)*X?)/\1, ╠isbn_issn=\4╣, /ig" |
    perl -ape "s/ n[o\.]{0,2} *([0-9]+[-–]*[0-9]*)[ ,\.]/, ╠issue=\1╣, /g" | # 'no. 1-3', 'hard to approximate within n1−ε'
    perl -ape "s/ vol(umes*)*[\. ]*([0-9vi]+([-–]+[0-9]+)*)( of)*/,\. ╠vol=\2╣, /ig" | # 'volume 1–4'
    perl -ape "s#arXiv[:/ ] *([0-9]{4}\.[0-9v]+|[^ ]+/[0-9\.]{4,}[0-9])#, ╠arxiv=\1╣, #ig" | # https://arxiv.org/help/arxiv_identifier
    perl -ape "s/ (Pages|pages|p\.*p\.*|pp|p\.|p|pp\.)* *([0-9]+) *[-–]+ *([0-9]+)[,\. ]/,\. ╠pages=\2–\3╣, /g" |
    perl -ape "s/ ([0-9]+)\(([0-9-]+)\):([0-9]+)[ –-]+([0-9]+)/, ╠vol=\1╣, ╠issue=\2╣, ╠pages=\3–\4╣, /" | # 52(12):1491–1552
    perl -ape "s/ ([0-9]+):([0-9]+)[–-]+([0-9]+)/, ╠vol=\1╣, ╠pages=\2–\3╣, /" |  # 3:131–150
    perl -ape "s/ ([0-9]+)pp\.*/, ╠numpages=\1╣, /g" |
    perl -ape "s/ \(((19|20)[0-9]{2})\)/,\.╠year=\1╣, /g" | # year '(1992)'
    perl -ape "s/[,\.]+ +((19|20)[0-9]{2})([,\)\. *]+)/, ╠year=\1╣, \3 /g" |
    perl -ape "s/[Tt]o [Aa]ppear( in)* *[:;\.]*/, ╠to_appear╣, /g" |
    perl -ape "s/ [Pp]reprint([^a-z])/, ╠preprint╣, \1/g" |
    perl -ape "s/ [Ii]n [Pp]ress([^a-z])/, ╠in_press╣, \1/g" |
    perl -ape "s/ [Ii]n [Pp]reparation([^a-z])/, ╠preprint╣, \1/g" |
    perl -ape "s/[[:punct:]] *[Ee]xtended [Aa]bstract[[:punct:]]/,/g" |
    perl -ape "s/([,\.\(\)]) *[Aa]ccepted *([\(\),\.])/\1, ╠accepted╣, \2/g" |
    perl -ape "s/[,\.] *[Ss]ubmitted *[,\.]/, ╠submitted╣, /g" |
    sed "s/[,\.] *\(\w+ *edition\) *[,\.]/, ╠edition_info=\1╣, /Ig" |
    sed "s/[,\.] *\([0-9]*[[:lower:]]* ed\.\) *[\,\,]/, ╠edition_info=\1╣, /Ig" |

    perl -ape "s/”/”, /g" |
    perl -ape "s/“/, “/g" |
    sed "s/,[ ,\.]*/, /g" |
    perl -ape "s/╣, (in|of) /╣, /g" |
    while read l; do auto_annotate_from_db "$l"; done |
    # Must not reomve Proc. before the journal is parsed
    while read ll; do parse_journal_from_db "$ll"; done |
    while read ll; do parse_proceedings "$ll"; done |
    while read ll; do parse_journal_from_db "$ll"; done |

    while read ll; do guess_authors "$ll"; done |
    while read ll; do guess_title "$ll"; done |

    # The next may be useful for production, but it is hell for testing.
    # while read ll; do auto_annotate_from_db_greedy "$ll"; done |
    while read l; do auto_annotate_from_db "$l"; done |

    perl -ape "s/(╠journal=[^╣]*╣)[, ]*([0-9]+) *\(([0-9]+)\)[ ,\.]/\1, ╠vol=\2╣, ╠issue=\3╣, /g" | # The number that comes after the journal's name is the volume (?)
    perl -ape "s/(╠journal=[^╣]*╣)[, ]*([0-9]+)[ ,\.]/\1, ╠vol=\2╣, /g" | # The number that comes after the journal's name is the volume (?)
    perl -ape "s/,[ \.,]*/, /g" |
    perl -ape "s/^\[[^ ]*\][ ,]*//g" |
    cat
